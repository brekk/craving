import type { DepMap, MadDependency } from "@/Dependencies"
import type { AppliedTheme, Theme } from "@/Theme"

import Dict from "Dictionary"
import { unless } from "Function"
import List from "List"
import Set from "Set"
import String from "String"

import {
  External,
  Local,
  Prelude,
  allDeps,
  isExternal,
  isLocal,
  isPrelude,
  name,
} from "@/Dependencies"
import { indent, quote, sandwich, unlines } from "@/String"
import { applyTheme } from "@/Theme"



printNode = pipe(
  name,
  quote,
  mappend($, ";"),
)

printNodesWithStyle = (i, pre, xs) => pipe(
  map(
    pipe(
      printNode,
      indent(i),
    ),
  ),
  unlines,
  unless(String.isEmpty, mappend(indent(i, pre ++ ";\n"))),
)(xs)

export alias Attribute = #[String, String]

renderAttribute = where {
  #[k, v] =>
    `${k}=${v};`
}
renderAttributes = (i, attrs) => pipe(
  map(
    pipe(
      renderAttribute,
      indent(i),
    ),
  ),
  unlines,
)(attrs)

cluster = (attrs, n, body) => `subgraph "${n}" {
    label="${n}";
    cluster=true;

    ${renderAttributes(2, attrs)}

    ${body}
  }`

nodeStyle = mappend("node ")

renderNodes = (theme, i, x) => pipe(
  (raw) => {
    print = pipe(
      sandwich("[", "]"),
      nodeStyle,
      printNodesWithStyle(i),
    )
    all = nodeStyle(theme.all) ++ ";"
    preludeNodes = pipe(
      List.filter(isPrelude),
      print(theme.nodes.prelude),
    )(raw)

    extNodes = pipe(
      List.filter(isExternal),
      print(theme.nodes.external),
    )(raw)

    localNodes = pipe(
      List.filter(isLocal),
      print(theme.nodes.local),
    )(raw)
    return [all, extNodes, localNodes, preludeNodes]
  },
  unlines,
)(x)

declareNodes :: AppliedTheme -> Set MadDependency -> String
export declareNodes = (theme, deps) => pipe(
  Set.toList,
  renderNodes(theme, 1),
)(deps)

// TEEN GIRL SQUAD
arrowd :: String -> MadDependency -> MadDependency -> String
arrowd = (style, a, z) => `${quote(name(a))} -> ${quote(name(z))}${
  String.isEmpty(style) ? "" : " [" ++ style ++ "]"
};`

relationshipRules = (theme, _a, _z) => {
  draw = arrowd($, _z, _a)
  return where(#[_z, _a]) {
    #[Prelude(_), Local(_)] =>
      draw(theme.edges.prelude)

    #[External(_), Local(_)] =>
      draw(theme.edges.external)

    #[Local(_), Local(_)] =>
      draw(theme.edges.local)

    _ =>
      draw("")
  }
}

relate :: AppliedTheme -> MadDependency -> List MadDependency -> String
export relate = (theme, a, zs) => {
  return pipe(
    map(
      pipe(
        relationshipRules(theme, a),
        indent(1),
      ),
    ),
    unlines,
  )(zs)
}


render :: Theme -> List Attribute -> DepMap -> String
export render = (_theme, attrs, depMap) => {
  theme = applyTheme(_theme)
  nodes = pipe(
    allDeps,
    declareNodes(theme),
  )(depMap)
  relations = pipe(
    Dict.toList,
    map(where { #[k, v] => relate(theme, k, v) }),
    unlines,
  )(depMap)

  return `digraph MadDeps {\n\n  \/\/ attributes\n\n${
    renderAttributes(1, attrs)
  }\n\n  \/\/ nodes\n\n${nodes}\n\n  \/\/ relationships\n\n${relations}\n}`
}
