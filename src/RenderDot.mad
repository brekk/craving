import type { DepMap, MadDependency } from "@/Dependencies"

import Dict from "Dictionary"
import { unless } from "Function"
import List from "List"
import Set from "Set"
import String from "String"

import { External, Local, Prelude, isExternal, isLocal, isPrelude, name } from "@/Dependencies"



quote = (x) => `"${x}"`
indent = (n, x) => `${String.repeat(' ', n * 2)}${x}`

unlines = String.join("\n")

/*
export COLORS = {
  PRELUDE: "#d62828",
  EXTERNAL: "#f77f00",
  LOCAL: "#fcbf49",
  FG: "#003049",
  BG: "#eae2b7",
}
*/

export COLORS = {
  PRELUDE: "#f4d35e",
  LOCAL: "#28afb0",
  EXTERNAL: "#ee964b",
  FG: "#1f271b",
  BG: "#19647e",
}

ALL_NODES = `[fontsize="40pt", fontname="Obviously Narrow", fontcolor="${COLORS.FG}"]`

PRELUDE_STYLE = `[fontsize="20pt", shape="rect", fillcolor="${
  COLORS.PRELUDE
}", style="filled", margin="0.25", fontname="Compadre"]`
EXTERNAL_STYLE = `[fillcolor="${COLORS.EXTERNAL}", style="filled", shape="invhouse"]`
LOCAL_STYLE = `[shape="rect", style="rounded,filled", fillcolor="${COLORS.LOCAL}", margin=0.25]`

allDeps :: DepMap -> Set MadDependency
export allDeps = pipe(
  Dict.toList,
  List.reduce(
    (s, x) => where(x) {
      #[k, ds] =>
        Set.merge(s, Set.insert(k, Set.fromList(ds)))
    },
    Set.empty,
  ),
)

printNode = pipe(
  name,
  quote,
  mappend($, ";"),
)

printNodesWithStyle = (i, pre, xs) => pipe(
  map(
    pipe(
      printNode,
      indent(i),
    ),
  ),
  unlines,
  unless(String.isEmpty, mappend(indent(i, pre) ++ ";\n")),
)(xs)

export alias Attribute = #[String, String]

renderAttribute = where {
  #[k, v] =>
    `${k}=${v};`
}
renderAttributes = (i, attrs) => pipe(
  map(
    pipe(
      renderAttribute,
      indent(i),
    ),
  ),
  unlines,
)(attrs)

cluster = (attrs, n, body) => `subgraph "${n}" {
    label="${n}";
    cluster=true;

    ${renderAttributes(2, attrs)}

    ${body}
  }`

nodeStyle = mappend("node ")

renderNodes = (i, x) => pipe(
  (raw) => {
    print = printNodesWithStyle(i)
    all = nodeStyle(ALL_NODES)
    preludeNodes = pipe(
      List.filter(isPrelude),
      print(nodeStyle(PRELUDE_STYLE)),
    )(raw)

    extNodes = pipe(
      List.filter(isExternal),
      print(nodeStyle(EXTERNAL_STYLE)),
    )(raw)

    localNodes = pipe(
      List.filter(isLocal),
      print(nodeStyle(LOCAL_STYLE)),
    )(raw)
    return [all, extNodes, localNodes, preludeNodes]
  },
  unlines,
)(x)

declareNodes :: Set MadDependency -> String
export declareNodes = pipe(
  Set.toList,
  renderNodes(1),
)

// TEEN GIRL SQUAD
arrowd :: String -> MadDependency -> MadDependency -> String
arrowd = (style, a, z) => `${quote(name(a))}:s -> ${quote(name(z))}${
  String.isEmpty(style) ? "" : " [" ++ style ++ "]"
};`

relationshipRules = (extToLocal, preludeToLocal, localToLocal, _a, _z) => {
  draw = arrowd($, _z, _a)
  return where(#[_z, _a]) {
    #[Prelude(_), Local(_)] =>
      draw(preludeToLocal)

    #[External(_), Local(_)] =>
      draw(extToLocal)

    #[Local(_), Local(_)] =>
      draw(localToLocal)

    _ =>
      draw("")
  }
}

EXT_TO_LOCAL = `color="${COLORS.EXTERNAL}", penwidth=2`
PRELUDE_TO_LOCAL = `style=dashed, color="${COLORS.PRELUDE}", penwidth=2`
LOCAL_TO_LOCAL = `style=bold, color="${COLORS.LOCAL}", penwidth=2`

relate :: MadDependency -> List MadDependency -> String
export relate = (a, zs) => {
  return pipe(
    map(
      pipe(
        relationshipRules(EXT_TO_LOCAL, PRELUDE_TO_LOCAL, LOCAL_TO_LOCAL, a),
        indent(1),
      ),
    ),
    unlines,
  )(zs)
}


render :: List Attribute -> DepMap -> String
export render = (attrs, depMap) => {
  nodes = pipe(
    allDeps,
    declareNodes,
  )(depMap)
  relations = pipe(
    Dict.toList,
    map(where { #[k, v] => relate(k, v) }),
    unlines,
  )(depMap)

  return `digraph MadDeps {\n\n  \/\/ attributes\n\n${
    renderAttributes(1, attrs)
  }\n\n  \/\/ nodes\n\n${nodes}\n\n  \/\/ relationships\n\n${relations}\n}`
}
